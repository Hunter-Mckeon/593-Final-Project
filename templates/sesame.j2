// generated_policies.rs - GENERATED by Final.py from websubmit.yml.
// Do not edit by hand; edit websubmit.yml or sesame.j2 instead.

use crate::policy::context::ContextData;
use mysql::prelude::Queryable;
use sesame::context::UnprotectedContext;
use sesame::policy::{Reason, SimplePolicy};
use sesame::SesameTypeOut;
use sesame_mysql::{schema_policy, SchemaPolicy};

{# Grab submissions table and answer column from YAML #}
{%- set submissions = tables["submissions"] -%}
{%- set answer_col = submissions.columns
    | selectattr("name", "equalto", "answer")
    | list
    | first -%}
{%- set admin_email = answer_col.allow or "admin@bu.edu" -%}

// This policy applies to the `answer` column in the `submissions` table.
// Table schema (from generated_k9db.sql):
//   0: ID
//   1: student_id
//   2: assignment_id
//   3: answer
#[schema_policy(table = "submissions", column = 3)]
#[derive(Clone)]
pub struct AccessControlPolicy {
    // Value of the student_id column for this row.
    student_id: String,
}

impl SimplePolicy for AccessControlPolicy {
    fn simple_name(&self) -> String {
        "AccessControlPolicy".to_string()
    }

    fn simple_check(&self, context: &UnprotectedContext, _reason: Reason) -> bool {
        type ContextDataOut = <ContextData as SesameTypeOut>::Out;
        let context: &ContextDataOut = context.downcast_ref().unwrap();

        // The user trying to view the submission.
        let user: &String = &context.user_email;

        // Allow if:
        //  1) The user is the student who owns the row, OR
        //  2) The user is the admin/professor from websubmit.yml (answer.allow).
        user == &self.student_id || user == "{{ admin_email }}"
    }

    fn simple_join_direct(&mut self, other: &mut Self) {
        // If we end up joining two rows with different owners,
        // we force the policy into a conservative state.
        if self.student_id != other.student_id {
            self.student_id = String::from("");
        }
    }
}

impl SchemaPolicy for AccessControlPolicy {
    fn from_row(table_name: &str, row: &Vec<mysql::Value>) -> Self
    where
        Self: Sized,
    {
        assert_eq!(table_name, "submissions");
        AccessControlPolicy {
            // Read the value of the student_id column from the submissions table.
            // NOTE: columns: 0 = ID, 1 = student_id, 2 = assignment_id, 3 = answer.
            student_id: mysql::from_value(row[1].clone()),
        }
    }
}
